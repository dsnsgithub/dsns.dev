---
export const prerender = false;

import { Octokit } from "@octokit/rest";

interface DisplayEvent {
	id: string;
	actor: { login: string; avatar_url: string };
	verb: string;
	object: string;
	description?: string;
	repo: string;
	url: string;
	timestamp: string;
}

const octokit = new Octokit({
	auth: import.meta.env.GITHUB_TOKEN
});

const detailCache = new Map<string, { title: string; body: string; merged?: boolean; url: string }>();

// Use globalThis to persist cache across requests
const globalCache = globalThis as any;
if (!globalCache.__githubEventsCache) {
	globalCache.__githubEventsCache = {
		data: null as DisplayEvent[] | null,
		timestamp: 0,
		TTL: 5 * 60 * 1000 // 5 minutes in milliseconds
	};
}
const eventsCache = globalCache.__githubEventsCache;

const cleanDescription = (text: string | null | undefined) => (text ? text.replace(/[#*`_]/g, "").trim() : "");

const formatDate = (iso: string) =>
	new Date(iso).toLocaleDateString(undefined, {
		month: "short",
		day: "numeric",
		hour: "numeric",
		minute: "numeric"
	});

async function fetchDetails(apiUrl: string) {
	if (detailCache.has(apiUrl)) return detailCache.get(apiUrl)!;
	try {
		const res = await octokit.request(`GET ${apiUrl}`);
		const data = {
			title: (res.data as any).title ?? "Untitled",
			body: cleanDescription((res.data as any).body),
			merged: (res.data as any).merged,
			url: (res.data as any).html_url
		};
		detailCache.set(apiUrl, data);
		return data;
	} catch {
		return { title: "Private or Deleted Content", body: "", url: "#" };
	}
}

async function fetchGitHubEvents(): Promise<DisplayEvent[]> {
	const events: DisplayEvent[] = [];

	try {
		const res = await octokit.rest.activity.listPublicEventsForUser({
			username: "dsnsgithub",
			per_page: 30,
			headers: { "X-GitHub-Api-Version": "2022-11-28" }
		});

		const allowedActions = ["opened", "closed", "reopened"];
		const ignoredTypes = ["PushEvent", "IssueCommentEvent", "PullRequestReviewCommentEvent", "CommitCommentEvent"];
		const rawEvents = res.data.filter((e) => !ignoredTypes.includes(e.type!));

		const processedPRs = new Set<string>();

		for (const event of rawEvents) {
			const { payload, actor, repo, created_at, id, type } = event;
			if (!created_at || !id) continue;

			const base = {
				id,
				actor: { login: actor.login, avatar_url: actor.avatar_url },
				repo: repo.name,
				timestamp: formatDate(created_at)
			};

			if (type === "PullRequestEvent" || type === "PullRequestReviewEvent") {
				const pr = (payload as any).pull_request;
				const prKey = `${repo.name}#${pr.number}`;
				if (!pr || processedPRs.has(prKey)) continue;

				let verb = "";
				if (type === "PullRequestEvent" && (payload as any).action === "closed" && pr.merged) {
					verb = "merged";
				} else if (type === "PullRequestReviewEvent") {
					const state = (payload as any).review.state?.toLowerCase();
					if (state === "commented") continue;
					verb = state.replace("_", " ");
				} else if (type === "PullRequestEvent" && allowedActions.includes((payload as any).action)) {
					verb = (payload as any).action;
				} else continue;

				const details = await fetchDetails(pr.url);
				processedPRs.add(prKey);
				events.push({ ...base, verb: verb + " pull request", object: `${details.title} (#${pr.number})`, description: details.body, url: details.url });
			} else if (type === "IssuesEvent") {
				const issue = (payload as any).issue;
				if (!issue) continue;
				const details = await fetchDetails(issue.url);
				events.push({ ...base, verb: (payload as any).action + " issue", object: `${details.title} (#${issue.number})`, description: details.body, url: details.url });
			} else if (type === "WatchEvent") {
				events.push({ ...base, verb: "starred", object: repo.name, url: `https://github.com/${repo.name}` });
			} else if (type === "ForkEvent") {
				const forkee = (payload as any).forkee;
				if (!forkee) continue;
				events.push({ ...base, verb: "forked", object: repo.name, description: `Original repository created by ${forkee.full_name}`, url: forkee.html_url });
			}
		}
	} catch (err) {
		console.error("GitHub fetch error:", err);
	}

	return events;
}

// Check cache and fetch if expired
let events: DisplayEvent[] = [];
const now = Date.now();

if (eventsCache.data && now - eventsCache.timestamp < eventsCache.TTL) {
	// Use cached data
	events = eventsCache.data;
	console.log("Using cached GitHub events");
} else {
	// Fetch fresh data and update cache
	events = await fetchGitHubEvents();
	eventsCache.data = events;
	eventsCache.timestamp = now;
	console.log("Fetched fresh GitHub events");
}
---

<div class="flex flex-col space-y-3">
	{events.length === 0 && <p class="py-4 text-center text-gray-500">No recent activity found.</p>}

	{
		events.map((item) => (
			<div class="group mx-2 rounded-xl bg-viola-50 p-4 transition-transform hover:scale-[1.01] sm:mx-4 sm:p-5">
				<a href={item.url} target="_blank" rel="noopener noreferrer" class="flex items-start space-x-3 sm:space-x-4">
					<img src={item.actor.avatar_url} alt={item.actor.login} class="h-8 w-8 shrink-0 rounded-full border-2 border-white bg-viola-100 shadow-sm sm:h-10 sm:w-10" />

					<div class="min-w-0 flex-1">
						<div class="flex flex-col sm:flex-row sm:items-center sm:justify-between">
							<p class="text-sm font-bold text-gray-900">
								{item.actor.login}
								<span class="mx-0.5 font-normal text-gray-500"> {item.verb} </span>
								<span class="text-viola-700">{item.object}</span>
							</p>
							<span class="mt-1 text-[10px] text-gray-400 sm:mt-0 sm:text-xs">{item.timestamp}</span>
						</div>

						{item.description && (
							<div class="mt-2" style="mask-image: linear-gradient(to bottom, black 70%, transparent); -webkit-mask-image: linear-gradient(to bottom, black 70%, transparent);">
								<p class="line-clamp-3 whitespace-pre-wrap text-xs text-gray-600">{item.description}</p>
							</div>
						)}

						<p class="mt-2 truncate text-[10px] font-semibold tracking-wide text-viola-700/80 sm:text-[11px]">{item.repo}</p>
					</div>
				</a>
			</div>
		))
	}
</div>
